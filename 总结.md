## 7.1-7.7

数组与哈希表

- 1.两数之和
- 49.字母异位词分组
- 128.最长连续序列





### 1.两数之和



两数之和

第一种解法，暴力解法，也就是使用双重循环，遍历数组中的每一对数字，检查它们的和是否等于目标值。如果相等就返回这两个数字索引。

```js
// 解法1: 数组
var twoSum = function (nums, target) {
  let len = nums.length;
  for (let i = 0; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }

  return [];
};

// console.log(twoSum([11, 15, 8, 7, 5, 4], 9));
```



第二种解法，

暴力解法的时间复杂度是O(n^2)，效率比较低。另一种高效的解法就是使用**哈希表**(在JavaScript中可以理解为对象或Map)。

这种解法只需遍历数组一次。

1. 创建一个空的哈希表。
2. 遍历数组，对于每个元素，计算它与目标值之间的差值。
3. 检查这个差值是否已经在哈希表中。如果存在，说明我们找到了一对解，返回它们的索引。
4. 如果差值不在哈希表中，将当前元素及其索引存入哈希表，继续遍历。

```js


// 解法2：哈希表
var twoSum2 = function (nums, target) {
  const map = {};
  let n1,
    len = nums.length;

  for (var i = 0; i < len; i++) {
    n1 = target - nums[i];
    if (map[n1] !== undefined) {
      return [map[n1], i];
    } else {
      map[nums[i]] = i;
    }
  }
  return [];
};

// console.log(twoSum2([0, 1, 8, 11, 15, 8, 7, 5, 4], 9));
```





#### 为什么用哈希表更好

使用哈希表来解决“两数之和”问题是一个非常自然的想法，原因在于哈希表能够提供快速的查找、插入和删除操作，平均时间复杂度可以达到O(1)。这对于**优化搜索类问题**特别有效。具体到这个问题上，哈希表的优势体现在以下几个方面：

1. **减少冗余计算**：通过预先存储已访问过的元素及其索引，我们可以避免像暴力解法那样进行大量的重复比较。
2. **定位快速**：对于每一个元素，我们可以通过计算目标值与当前元素的差值，直接在哈希表中查询这个差值是否存在。如果存在，意味着我们找到了那两个数，因为它们的和正好等于目标值。这种查询操作在哈希表中是非常高效的。
3. **线性时间复杂度**：利用哈希表，我们只需要遍历一次数组就可以解决问题，将整体的时间复杂度从暴力解法的O(n^2)降低到了O(n)，大大提高了算法的效率，特别是在处理大规模数据集时，这种效率提升会更加明显。
4. **空间换时间**：虽然引入哈希表会增加额外的空间消耗（O(n)），但在很多实际应用中，为了获得更快的运行速度，这种空间上的牺牲是值得的，尤其是当处理大量数据或者需要高性能时。

因此，在面对寻找**配对、计数、去重**等问题时，考虑使用哈希表是一种常见的优化策略，它体现了“空间换时间”的经典计算机科学思想。





### 49.字母异位词分组

解题思路：









```js
function groupAnagrams(strs) {
    const anagramMap = new Map(); // 使用Map作为哈希表

    // 遍历字符串数组
    for (const str of strs) {
        // 对当前字符串进行排序，得到排序后的字符串
        const sortedStr = str.split('').sort().join('');
        
        // 如果排序后的字符串已经在哈希表中，则将当前字符串添加到对应的数组中
        if (anagramMap.has(sortedStr)) {
            anagramMap.get(sortedStr).push(str);
        } else {
            // 否则，创建一个新的数组，并将当前字符串作为第一个元素
            anagramMap.set(sortedStr, [str]);
        }
    }

    // 收集所有数组作为最终结果
    return Array.from(anagramMap.values());
}


let res = groupAnagrams(["bddddddddb", "bbbbbbbbbbc", "hhh", "ab", "ba"]);
console.log("【res】", res);



// 题目描述：

// 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
// 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。

// 提示：
// 1 <= strs.length <= 104
// 0 <= strs[i].length <= 100
// strs[i] 仅包含小写字母

let res = groupAnagrams(["bddddddddb", "bbbbbbbbbbc", "hhh", "ab", "ba"]);
console.log("【res】", res);

// 
var groupAnagrams = function (strs) {
  let map = new Map();
  for (const s of strs) {
    let hashKey = s.split("").sort().join("");

    if (map.has(hashKey)) {
      map.get(hashKey).push(s);
    } else {
      map.set(hashKey, [s]);
    }
  }

  return Array.from(map.values());
};

// 时间复杂度：O(n*k)
// var groupAnagrams = function (strs) {
//   let map = new Map();

//   for (const s of strs) {
//     let hashKey = new Array(26).fill(0);
//     for (const c of s) {
//       hashKey[c.charCodeAt() - "a".charCodeAt()] += 1;
//     }

//     hashKey = hashKey.join();

//     if (map.has(hashKey)) {
//       map.get(hashKey).push(s);
//     } else {
//       map.set(hashKey, [s]);
//     }
//   }

//   return Array.from(map.values());
// };

```















### 128.最长连续序列



```js
// 时间复杂度 O(n)  空间复杂度 O(n)
var longestConsecutive = function (nums) {
  let set = new Set(nums);
  let maxLen = 0;
  for (const num of set) {
    if (!set.has(num - 1)) {
      let next = num + 1;
      while (set.has(next)) next++;
      maxLen = Math.max(maxLen, next - num);
    }
  }
  return maxLen;
};
```



















































